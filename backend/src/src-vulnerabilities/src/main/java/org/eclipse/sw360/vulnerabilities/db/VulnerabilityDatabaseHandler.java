/*
 * Copyright Siemens AG, 2016. Part of the SW360 Portal Project.
 *
 * This program and the accompanying materials are made
 * available under the terms of the Eclipse Public License 2.0
 * which is available at https://www.eclipse.org/legal/epl-2.0/
 *
 * SPDX-License-Identifier: EPL-2.0
 */
package org.eclipse.sw360.vulnerabilities.db;

import com.google.common.collect.ImmutableList;
import com.google.common.collect.Sets;

import org.eclipse.sw360.datahandler.common.DatabaseSettings;
import org.eclipse.sw360.datahandler.couchdb.DatabaseConnector;
import org.eclipse.sw360.datahandler.thrift.RequestStatus;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.ReleaseVulnerabilityRelation;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.Vulnerability;
import org.eclipse.sw360.datahandler.thrift.vulnerabilities.VulnerabilityWithReleaseRelations;
import org.eclipse.sw360.vulnerabilities.common.VulnerabilityMapper;

import org.apache.commons.lang.StringUtils;
import org.apache.logging.log4j.LogManager;
import org.apache.logging.log4j.Logger;
import org.apache.thrift.TBase;

import java.net.MalformedURLException;
import java.util.*;

/**
 * Class for accessing the CouchDB database
 *
 * @author stefan.jaeger@evosoft.com
 */
public class VulnerabilityDatabaseHandler {

    private static final Logger log = LogManager.getLogger(VulnerabilityDatabaseHandler.class);

    private final VulnerabilityRepository vulRepo;
    private final VulnerabilityRelationRepository relationRepo;

    public VulnerabilityDatabaseHandler() throws MalformedURLException {
        DatabaseConnector db = new DatabaseConnector(DatabaseSettings.getConfiguredHttpClient(),
                DatabaseSettings.COUCH_DB_VM);

        vulRepo = new VulnerabilityRepository(db);
        relationRepo = new VulnerabilityRelationRepository(db);
    }

    public <T extends TBase> RequestStatus add(T element) {
        if (element == null) {
            log.error("cannot add null element");
            return RequestStatus.FAILURE;
        }
        log.debug("adding element " + element.toString());
        try {
            if (Vulnerability.class.isAssignableFrom(element.getClass())) {
                vulRepo.add((Vulnerability) element);
                log.info("Vulnerability id = " + ((Vulnerability) element).getId());
            } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(element.getClass())) {
                relationRepo.add((ReleaseVulnerabilityRelation) element);
            } else {
                throw new IllegalArgumentException("unknown type " + element.getClass().getSimpleName());
            }
            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on adding " + element.getClass().getSimpleName() + ": " + e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public <T extends TBase> RequestStatus add(Class<T> type, Collection<T> elements) {
        if (type == null || elements == null) {
            log.error("type/elements cannot be null");
            return RequestStatus.FAILURE;
        }
        try {
            log.debug("adding " + elements.size() + " elements via bulk");
            if (Vulnerability.class.isAssignableFrom(type)) {
                vulRepo.executeBulk(elements);
            } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type)) {
                relationRepo.executeBulk(elements);
            } else {
                throw new IllegalArgumentException("unknown type " + type.getSimpleName());
            }

            log.debug("adding " + elements.size() + " elements via bulk finished");
            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on bulk updating " + type.getSimpleName() + ": " + e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public RequestStatus addRelationIfNecessary(String releaseId, String vulnerabilityId, Optional<String> usedNeedle) {
        ReleaseVulnerabilityRelation relation = getRelationByIds(releaseId, vulnerabilityId);
        if (relation != null) {
            if (usedNeedle.isPresent() && !relation.getUsedNeedle().equals(usedNeedle.get())) {
                relation.setUsedNeedle(usedNeedle.get());
                return update(relation);
            }
            return RequestStatus.SUCCESS;
        } else {
            relation = new ReleaseVulnerabilityRelation(releaseId, vulnerabilityId);
            if (usedNeedle.isPresent()) {
                relation.setUsedNeedle(usedNeedle.get());
            }
            return add(relation);
        }
    }

    public RequestStatus addRelationsIfNecessary(String releaseId, List<String> vulnerabilityIds) {
        RequestStatus requestStatus = RequestStatus.SUCCESS;
        for (String vulnerabilityId : vulnerabilityIds) {
            RequestStatus singleOperationStatus = addRelationIfNecessary(releaseId, vulnerabilityId, Optional.empty());
            if (RequestStatus.FAILURE.equals(singleOperationStatus)) {
                requestStatus = RequestStatus.FAILURE;
            }
        }
        return requestStatus;
    }

    public RequestStatus addRelationsIfNecessary(String releaseId, Map<String, List<String>> needlesToVulnerabilityIds) {
        RequestStatus requestStatus = RequestStatus.SUCCESS;
        for (Map.Entry<String, List<String>> needleWithVulnerabilityIds : needlesToVulnerabilityIds.entrySet()) {
            String usedNeedle = needleWithVulnerabilityIds.getKey();
            List<String> vulnerabilityIds = needleWithVulnerabilityIds.getValue();

            for (String vulnerabilityId : vulnerabilityIds) {
                RequestStatus singleOperationStatus = addRelationIfNecessary(releaseId,
                        vulnerabilityId,
                        Optional.ofNullable(usedNeedle));
                if (RequestStatus.FAILURE.equals(singleOperationStatus)) {
                    requestStatus = RequestStatus.FAILURE;
                }
            }
        }
        return requestStatus;
    }

    public <T extends TBase> RequestStatus update(T element) {
        if (element == null) {
            log.error("cannot update null element");
            return RequestStatus.FAILURE;
        }
        try {
            if (Vulnerability.class.isAssignableFrom(element.getClass())) {
                vulRepo.update(VulnerabilityMapper.setLastUpdate((Vulnerability) element));
            } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(element.getClass())) {
                relationRepo.update((ReleaseVulnerabilityRelation) element);
            } else {
                throw new IllegalArgumentException("unknown type " + element.getClass().getSimpleName());
            }

            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on updating " + element.getClass().getSimpleName() + ": " + e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public <T extends TBase> RequestStatus delete(T element) {
        if (element == null) {
            log.error("cannot remove null element");
            return RequestStatus.FAILURE;
        }
        try {
            if (Vulnerability.class.isAssignableFrom(element.getClass())) {
                vulRepo.remove((Vulnerability) element);
            } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(element.getClass())) {
                relationRepo.remove((ReleaseVulnerabilityRelation) element);
            } else {
                throw new IllegalArgumentException("unknown type " + element.getClass().getSimpleName());
            }

            return RequestStatus.SUCCESS;
        } catch (Exception e) {
            log.error("error on removing " + element.getClass().getSimpleName() + ": " + e.getMessage());
            return RequestStatus.FAILURE;
        }
    }

    public <T extends TBase> List<T> getAll(Class<T> type) {
        if (type == null) {
            log.error("type cannot be null");
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (List<T>) vulRepo.getAll();
        } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type)) {
            return (List<T>) relationRepo.getAll();
        } else {
            throw new IllegalArgumentException("unknown type " + type.getSimpleName());
        }
    }

    public <T extends TBase> T getById(Class<T> type, String id) {
        if (type == null || StringUtils.isEmpty(id)) {
            log.error("type/id cannot be null " + type + " " + id);
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (T) vulRepo.get(id);
        } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type)) {
            return (T) relationRepo.get(id);
        } else {
            throw new IllegalArgumentException("unknown type " + type.getSimpleName());
        }
    }

    public <T extends TBase> List<T> getByIds(Class<T> type, Collection<String> ids) {
        if (type == null || ids == null) {
            log.error("type/ids cannot be null " + type + " " + ids);
            return ImmutableList.of();
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (List<T>) vulRepo.get(ids);
        } else if (ReleaseVulnerabilityRelation.class.isAssignableFrom(type)) {
            return (List<T>) relationRepo.get(ids);
        } else {
            throw new IllegalArgumentException("unknown type " + type.getSimpleName());
        }
    }

    public List<Vulnerability> getByExternalIdOrVulnerableConfig(String externalId, String vulnerableConfig) {
        return vulRepo.getVulnerabilitiesByExternalIdOrVulnerableConfig(externalId, vulnerableConfig);
    }

    public ReleaseVulnerabilityRelation getRelationByIds(String releaseId, String vulnerabilityId) {
        if (StringUtils.isEmpty(releaseId) || StringUtils.isEmpty(vulnerabilityId)) {
            log.error("releaseId/vulnerabilityId cannot be null " + releaseId + " " + vulnerabilityId);
            return null;
        }
        return relationRepo.getRelationByIds(releaseId, vulnerabilityId);
    }

    public ReleaseVulnerabilityRelation getRelationByIds(ReleaseVulnerabilityRelation relation) {
        return getRelationByIds(relation.getReleaseId(), relation.getVulnerabilityId());
    }

    public List<ReleaseVulnerabilityRelation> getRelationsByReleaseIds(Collection<String> releaseIds) {
        if (releaseIds == null || releaseIds.isEmpty()) {
            log.error("releaseIds cannot be null/empty");
            return null;
        }
        return relationRepo.getRelationsByReleaseIds(releaseIds);
    }

    public <T extends TBase> T getByExternalId(Class<T> type, String externalId) {
        if (type == null || StringUtils.isEmpty(externalId)) {
            log.error("type/externalId cannot be null " + type + " " + externalId);
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (T) vulRepo.getVulnerabilityByExternalid(externalId);
        } else {
            throw new IllegalArgumentException("unknown type " + type.getSimpleName());
        }
    }

    public <T extends TBase> List<T> getLastUpdated(Class<T> type, int limit) {
        if (type == null) {
            log.error("type cannot be null");
            return null;
        }
        if (Vulnerability.class.isAssignableFrom(type)) {
            return (List<T>) vulRepo.getVulnerabilitiesByLastUpdate(limit);
        } else {
            return null;
        }
    }

    public VulnerabilityWithReleaseRelations getVulnerabilityWithReleaseRelationsByExternalId(String externalId) {
        Vulnerability vulnerability = vulRepo.getVulnerabilityByExternalid(externalId);
        if (vulnerability != null) {
            List<ReleaseVulnerabilityRelation> relations = relationRepo.getRelationsByVulnerabilityId(vulnerability.getId());
            return new VulnerabilityWithReleaseRelations(vulnerability, relations);
        } else {
            return null;
        }
    }

    public int getTotalVulnerabilityCount() {
        return vulRepo.getDocumentCount();
    }

    public List<ReleaseVulnerabilityRelation> getReleaseVulnerabilityRelationsByReleaseId(String releaseId) {
        return relationRepo.getRelationsByReleaseIds(Sets.newHashSet(releaseId));
    }
}
